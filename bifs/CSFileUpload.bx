/**
 * This is a BOXLANG BIF.  Please note that all BIFs are registered
 * as singletons.
 *
 * Annotations you can use on a BIF:
 * <pre>
 * // The alias of the BIF, defaults to the name of the Class
 * @BoxBIF - The BIF is registered as the name of the class
 * @BoxBIF( 'myBifAlias' ) - Register with the specific name
 * @BoxBIF( [ 'myBifAlias', 'myOtherBifAlias' ] ) - Register with all these names
 * @BoxMember( 'string' ) : Register also as a member method on strings.
 * @BoxMember( { 'string' : { name : '', objectArgument : '' }, 'array' : { name : '', objectArgument : '' } } ) - Register on multiple types
 * </pre>
 *
 * The runtime injects the following into the `variables` scope:
 *
 * - moduleRecord : The ModuleRecord instance
 *
 */
import bxModules.bxcloudstorage.models.CloudStorageService;

@BoxBIF
class {
    @inject
    property name="moduleRecord";

    /**
     * Upload a local file or binary data to S3, choosing single PUT or multipart upload based on size.
     * Streams from disk for low memory usage when using file path.
     *
     * @source Either an absolute path to the local file to upload (string), or a binary object to upload directly.
     * @destination Cloud destination: `s3:///bucket/key` or relative key (resolved via settings in CloudStorageService).
     * @multipartThreshold File size in bytes above which multipart upload is used (default 25MB; overridable via `UploadMultipartThreshold`).
     * @partSize Size in bytes for each multipart part (default 16MB; minimum 5MB per S3 rules; overridable via `UploadPartSize`).
     * @maxConcurrent Maximum concurrent part uploads for multipart mode (default from code 54; overridable via `UploadMaxConcurrent`).
     * @fileTimeout Timeout in seconds for the overall upload in multipart mode (default 60; overridable via `FileTransferTimeout`).
     * @contentType Optional MIME type for binary uploads. For file path uploads, auto-detected if not specified.
     * @return Struct: `{ success:boolean, message:string, bucketName:string, objectKey:string, etag?:string, parts?:numeric }`. On failure, `success=false` with `message`.
     */
    struct function invoke(
        required any source,
        required string destination,
        numeric multipartThreshold = 25 * 1024 * 1024,
        numeric partSize = 16 * 1024 * 1024,
        numeric maxConcurrent = 54,
        numeric fileTimeout = 60,
        string contentType = ""
    ) {
        // Determine if source is binary or file path
        var isBinarySource = isBinary( arguments.source );
        var sourceFilePath = "";
        var binaryData = "";
        var size = 0;
        var sourceName = "";

        if( isBinarySource ){
            // Source is binary data
            binaryData = arguments.source;
            size = arrayLen( binaryData );
            sourceName = "binary-upload";
        } else {
            // Source is file path
            sourceFilePath = arguments.source;
            if( !fileExists( sourceFilePath ) ){
                return { success=false, message='CSFileUpload: Local file not found', bucketName='', objectKey='' };
            }
            size = fileInfo( sourceFilePath ).size;
            sourceName = sourceFilePath;
        }

        if( size == 0 ){
            // Edge case: empty file/binary still valid; treat as small
        }

        // Override thresholds from module settings if present
        try {
            if( val( moduleRecord?.settings?.UploadMultipartThreshold ) ) multipartThreshold = val( moduleRecord.settings.UploadMultipartThreshold );
            if( val( moduleRecord?.settings?.UploadPartSize ) ) partSize = val( moduleRecord.settings.UploadPartSize );
            if( val( moduleRecord?.settings?.UploadMaxConcurrent ) ) maxConcurrent = val( moduleRecord.settings.UploadMaxConcurrent );
            if( val( moduleRecord?.settings?.FileTransferTimeout ) ) fileTimeout = val( moduleRecord.settings.FileTransferTimeout );
        } catch( any ignore ){}

        if( arguments.partSize < 5 * 1024 * 1024 ) arguments.partSize = 5 * 1024 * 1024;

        // Use CloudStorageService to get the storage and parse destination object
		var cloud = new CloudStorageService().getStorageForPath( arguments.destination );
        // Prepare transfer monitoring
        var monitor = new CloudStorageService().getTransferMonitor();
        var uploadId = createObject( "java", "java.util.UUID" ).randomUUID().toString();

        // Small file: single putObject via cloud.storage
        if( size <= multipartThreshold ){
            // Register upload in monitor
            try { monitor.registerUpload( uploadId, { method: "single-put", totalChunks: 1, filename: sourceName } ); } catch( any ignore ){}
            try {
                var mimeType = arguments.contentType;
                if( !len( mimeType ) && !isBinarySource ){
                    try { mimeType = fileGetMimeType( sourceFilePath ); } catch( any ignore ){}
                }

                // Get binary data
                var uploadData = isBinarySource ? binaryData : fileReadBinary( sourceFilePath );

				writeLog( log="CloudStorage", type="debug", text="CSFileUpload: Performing single PUT for small " & ( isBinarySource ? "binary" : "file" ) & " upload: " & sourceName & " to " & arguments.destination );
                var putResp = cloud.storage.putObject( cloud.bucketName, cloud.objectKey, uploadData, mimeType );
				writeLog( log="CloudStorage", type="info", text="CSFileUpload: Single PUT upload completed: " & sourceName & " to " & arguments.destination );
                try { monitor.setCompletedChunks( uploadId, 1 ); } catch( any ignore ){}
                try { monitor.finishUpload( uploadId, true ); } catch( any ignore ){}
                return { success=true, message='uploaded', bucketName=cloud.bucketName, objectKey=cloud.objectKey, etag=putResp?.eTag ?: '' };
            } catch( any e ) {
				writeLog( log="CloudStorage", type="error", text="CSFileUpload: Small file upload failed: " & e.message );
                try { monitor.finishUpload( uploadId, false ); } catch( any ignore ){}
                return { success=false, message='CSFileUpload small put failed: ' & e.message, bucketName=cloud.bucketName, objectKey=cloud.objectKey };
            }
        }
        // Note: Multipart upload from binary data requires file path; write temp file if binary source
        try {
            if( isBinarySource ){
                // Binary source: write to temp file for multipart upload
                sourceFilePath = getTempFile( getTempDirectory(), "cs-upload-" );
                fileWrite( sourceFilePath, binaryData );
            }

			writeLog( log="CloudStorage", type="debug", text="CSFileUpload: Performing multipart upload for large " & ( isBinarySource ? "binary" : "file" ) & ": ( " & size & " bytes) " & sourceName & " to " & arguments.destination );
            var partsCount = 1;
            try { partsCount = int( ( size + arguments.partSize - 1 ) / arguments.partSize ); } catch( any ignore ){}
            try { monitor.registerUpload( uploadId, { method: "multipart", totalChunks: partsCount, filename: sourceName } ); } catch( any ignore ){}
            var uploadResp = cloud.storage.multipartUploadAsync(
                cloud.bucketName,
                cloud.objectKey,
                sourceFilePath,
				arguments.partSize,
                maxConcurrent,
                fileTimeout
            );
            if( structKeyExists( uploadResp, "error" ) && uploadResp.error ){
				writeLog( log="CloudStorage", type="error", text="CSFileUpload: Multipart upload failed: " & uploadResp.message );
                try { monitor.finishUpload( uploadId, false ); } catch( any ignore ){}

                // Clean up temp file if we created one
                if( isBinarySource && len( sourceFilePath ) && fileExists( sourceFilePath ) ){
                    try { fileDelete( sourceFilePath ); } catch( any ignore ){}
                }
                return { success=false, message='CSFileUpload multipart failed: ' & uploadResp.message, bucketName=cloud.bucketName, objectKey=cloud.objectKey };
            }
			writeLog( log="CloudStorage", type="info", text="CSFileUpload: Multipart upload completed: " & sourceName & " to " & arguments.destination );
            try { monitor.setCompletedChunks( uploadId, partsCount ); } catch( any ignore ){}
            try { monitor.finishUpload( uploadId, true ); } catch( any ignore ){}

            // Clean up temp file if we created one
            if( isBinarySource && len( sourceFilePath ) && fileExists( sourceFilePath ) ){
                try { fileDelete( sourceFilePath ); } catch( any ignore ){}
            }

            return {
                success=true,
                message='uploaded (multipart)',
                bucketName=cloud.bucketName,
                objectKey=cloud.objectKey,
                etag=uploadResp.eTag ?: '',
                parts=uploadResp.parts ?: 0
            };
        } catch( any e ) {
			writeLog( log="CloudStorage", type="error", text="CSFileUpload: Multipart upload exception: " & e.message );
            try { monitor.finishUpload( uploadId, false ); } catch( any ignore ){}
            // Clean up temp file if we created one
            if( isBinarySource && len( sourceFilePath ) && fileExists( sourceFilePath ) ){
                try { fileDelete( sourceFilePath ); } catch( any ignore ){}
            };
            return { success=false, message='CSFileUpload multipart failed: ' & e.message, bucketName=cloud.bucketName, objectKey=cloud.objectKey };
        }
    }
}
